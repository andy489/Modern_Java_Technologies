# Password Vault :closed_lock_with_key:

В днешни времена, едно от най-важните неща е да предпазваме личната си информация в Интернет. Една от фаталните грешки, която правят доста хора, е да използват една и съща парола във всички сайтове или да използват слаби пароли, включващи думи от речника, имена и т.н. Можем да подобрим своята киберсигурност като създадем приложение, което да реши всички тези проблеми.

Нашият мениджър на пароли ще представлява client-server приложение, като сървърът ще се грижи за всички нужди на клиентите, а те само трябва да се удостоверят пред него. Клиентите ще могат да се регистрират, login-ват, logout-ват, за да докажат самоличността си, след което ще могат да си запазват супер-сигурните пароли и след това да си ги взимат/променят.

## Server

- Сървърът трябва да може да обслужва множество клиенти едновременно
- Сървърът получава команди от клиентите и връща подходящ отговор
- Сървърът трябва да може да проверява дали дадена парола е компрометирана и не е сигурна за ползване
- Сървърът трябва да пази паролите по сигурен начин
- Сървърът трябва да генерира надеждни пароли

### Проверка за компрометирани пароли

При добавяне на нова парола от потребител за даден сайт (`add-password facebook.com pesho@gmail.com P@ssw0rd`), сървърът трябва да провери дали паролата не е била компрометирана и ако е, да върне подходяща грешка.
За целта може да използвате следното [API](https://www.enzoic.com/docs-passwords-api/).
Заявките към REST API-то изискват authentication чрез API key, какъвто може да получите като се регистрирате [тук](https://www.enzoic.com/free-trial-2/).

За по-лесно използване, заместете вашите *<api_key>* и *<api_secret>* [тук](https://repl.it/@ZdravkoGyurov/ExtrasmallReasonableFrontend#index.js) и използвайте резултата за правeне на заявки.

Примерна *HTTP GET* заявка:
URL:
https://api.enzoic.com/passwords?**sha1**=a94a8fe5ccb19ba61c4c0873d391e987982fbbd3&**md5**=098f6bcd4621d373cade4e832627b4f6&**sha256**=9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 \
Header: `authorization: basic base64("api_key:api_secret")`

Примерен *HTTP response*:

``` javascript
{
    "revealedInExposure":true,
    "relativeExposureFrequency":4,
    "exposureCount":2735
}
```

### Хеширане и криптиране

При регистрация, паролата на новия потребител трябва да се пази хеширана на сървъра, а всяка негова парола за даден сайт трябва да се пази криптирана, за да може при нужда да се декриптира.
Използвайте хеширащи и криптиращи алгоритми по ваш избор.

## Client

Клиентът трябва да има command line interface със следните команди

#### Регистрация в системата
- `register <user> <password> <password-repeat>`
- регистрира нов потребител, като при сървъра *(във файл, съдържащ паролите на всички потребители)* се запазва паролата в хеширан вид и се създава нов файл, за съхраняване на всички пароли *(криптирани, за да може да се връщат на потребителя, но да не се запазват в чист вид)* на този потребител

#### Вход в системата
- `login <user> <password>`
- login-ва потребител, при неактивност от една минута, потребителят трябва да бъде logout-нат автоматично

#### Изход от системата
- `logout`
- logout-ва потребител

#### Извличане на парола за даден сайт
- `retrieve-credentials <website> <user>`
- връща потребителското име и паролата на потребителя, с които се е регистрирал в дадения сайт

#### Генериране на парола
- `generate-password <website> <user>`
- генерира и запазва парола на потребителя за даден сайт, като се посочва и потребителското име, с коeто ще се направи регистрацията в сайта

#### Добавяне на парола
- `add-password <website> <user> <password>`
- добавя подадената от потребителя парола, като сървърът проверява дали тази парола е сигурна чрез REST API-то, и ако е, я запазва

#### Премахване на парола
- `remove-password <website> <user>`
- премахва запазена парола на потребителя за даден сайт

#### Прекратяване на връзката
- `disconnect` - прекратява връзката между клиента и сървъра

### Пример за валидни входни данни и отговори

``` bash
> login pesho peshopass
> Login successful

> generate-password facebook.com pesho@gmail.com
> _rrR~S>k$[8+Ps/x2WyaFv

> retrieve-credentials facebook.com pesho@gmail.com
> _rrR~S>k$[8+Ps/x2WyaFv

> remove-password facebook.com pesho@gmail.com
> Password successfully removed

> logout
> Logout successful

> disconnect
> Disconnected
```

Всякакви допълнителни функционалности, за които се сетите, са добре дошли.

## Съобщения за грешки

При неправилно използване на програмата, на потребителя да се извеждат подходящи съобщения за грешка.

При възникване програмна грешка, на потребителя да се извежда само уместна за него информация. Техническа информация за самата грешка и stackтraces да се записват във файл на файловата система - няма определен формат за записване на грешката.

Например, нерелевантно е при команда на потребител и възникнал проблем с мрежовата комуникация, да се изписва грешка от вида на "IO exception occurred: connection reset", по-подходящо би било "Unable to connect to the server. Try again later or contact administrator by providing the logs in <path_to_logs_file>".

При възникване на програмна грешка от страна на сървъра, подходящо съобщение се изписва на конзолата и във файл, като освен това, във файла се записва допълнителна информация (например, при заявка на кой потребител е възникнала грешката, ако въобще е обвързана с потребителско взаимодействие) и stacktraces.

## Submission

Качете в грейдъра `.zip` архив на познатите директории `src` и `test`. Ако пакетирате допълнителни файлове (които не са .java), те трябва да са в корена на архива, на нивото на `src` и `test`.
В грейдъра няма да има автоматизирани референтни тестове.
Проектът ви трябва да е качен в грейдъра не по-късно от 18:00 в деня преди датата на защитата.

Успех!
