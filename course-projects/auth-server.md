# Authentication Server :cop:

Когато се занимаваме с програмиране, няма как да избегнем въпросите, свързани със security. Обикновено имаме система, съставена от няколко компонента (наречени *микросървиси*) и един security server, който отговаря за комуникацията между потребителя и системата и тази между микросървисите да бъде защитена.

### Authentication vs Authorization

Най-общо, *authentication* наричаме проверката, дали потребителят, със своето име и парола, който опитва да се логне в системата, съществува в нея.

*Authorization* проверката, от друга страна, се извършва срещу вече логнати потребители. Тя се състои в това дали потребителят има право да извърши операцията, която иска - ако има, му позволяваме, ако не - извеждаме подходящо съобщение за грешка.

Например, всички ние сме потребители в СУСИ. Когато се логваме, минаваме през *authentication check*. Когато Стойо нанася оценките от курса, СУСИ се уверява, че той има необходимите права да нанася оценки и чак тогава му позволява да го направи.

### Audit Log

[Audit Log-ът](https://en.wikipedia.org/wiki/Audit_trail) е дневник, който пази информация за различни събития, свързани със сигурността, които са настъпили в системата ни. Такива събития могат да са например промяна на атрибутите на даден потребител, или пък негово нетипично или рисковано поведение.

#### А каква е ползата от това да се пази audit log на системата?

Чрез audit logging, бързо можем да открием кой е направил грешна конфигурация на системата ни, или пък кой (и от къде) е направил многократни неуспешни опити да се логне. Във втория сценарий, можем да продължим с анализа - с едно и също потребителско име ли е опитал да се логне, ако не, може би е опитал да направи DoS (Denial of Service) атака, проверяваме дали е от един IP адрес (хакерите в днешно време не са толкова глупави). Ако пък потребителят е един и същ, може това да е опит да се "разбие" профила му.

Използването на audit logging е задължително за всяко по-сериозно приложение, платформа или онлайн услуга. В нашата задача ще използваме един простичък механизъм, но в практиката съществуват немалко препятствия, които трябва да се вземат под внимание. Няколко линка с информация за по-любопитните:

- [What Are Audit Logs? | blogpost by Rodney Smith](https://rollout.io/blog/audit-logs/)
- [Audit logs for security and compliance | blogpost by Daniel Berman | long one, contains Linux examples of audit logging](https://logz.io/blog/audit-logs-security-compliance/)
- [Audit Log | Martin Fowler short blogpost](https://martinfowler.com/eaaDev/AuditLog.html)

## Условие

Имплементирайте ***сървър***, който да се грижи за authentication и authorization на потребители, както и конзолен ***клиент*** (CLI, Command-Line Interface), който да може да си комуникира с него. Сървърът трябва да поддържа паралелна работа с множество клиенти.

Когато един потребител "влезе" в системата, за него се създава т. нар. ***потребителска сесия***. Тя има уникален идентификатор и време, за което е валидна. При успешен вход, потребителят получава този идентификатор и чрез него може да изпълнява операциите, които изискват authentication и authorization.

Потребителите на Authentication Server-а са три типа:

- unauthenticated
- authenticated
- admin (подтип на authenticated потребители)
 
Сървърът предлага различен набор от функционалности на различните типове потребители. Затова, може да разделим и достъпните операции на няколко типа.

### Unsecured команди

За изпълнението на unsecured командите, не е необходима валидна потребителска сесия, тоест не е нужно да подаваме session ID като параметър.

- **Регистрация**

  Добавяне на нов потребител, само ако вече не съществува друг потребител с такова име. След успешна регистрация, потребителят бива логнат автоматично.

  ```bash
  register --username <username> --password <password> --first-name <firstName> --last-name <lastName> --email <email>
  ```
  
- **Вход**

  Потребителите могат да влизат в системата по два начина:

  - чрез своето потребителско име и парола 
  - чрез уникален идентификатор на вече съществуваща login сесия.

  **Сесията** е обект, който пази уникален идентификатор (*session ID*) и *time-to-live (ttl)*.

  В един момент един потребител може да има само една валидна сесия. Тя се създава в момента на успешен login, и session ID-то се връща на потребителя, за да може той да го преизползва (например от друг терминал). 
  След изтичане на time-to-live периода, сесията бива унищожена - потребителят e logout-нат и след това не може да преизползва това session ID за логване, а трябва да го направи със своето потребителско име и парола.
   
  Командите могат да имат следният вид:
  
  ```bash
  login -–username <username> --password <password>
  login -–session-id <sessionId>
  ```

#### Failed login

   При надвишаване на определен брой неуспешни опити за вход в системата, потребителят се lock-ва за определен период от време. Потребителят може да направи следващ опит за логин едва след като това време изтече.
   Броят неуспешни опити и lock периодът са част от конфигурацията на сървъра.
   
### Secured команди

Това са командите, достъпни за потребителите, които имат валидна сесия. Всички имат задължителен параметър session ID.
Също могат да бъдат разделени на две групи - такива, които са достъпни за всички потребители и такива, които са само за администратори.

#### Основни команди

- **Промяна на потребителските данни**

  Потребителите могат да променят своите *данни* (потребителско име, име, фамилия и мейл):

  ```bash
  update-user -–session-id <session-id>  -–new-username <newUsername> --new-first-name <newFirstName> --new-last-name <newLastName> --new-email <email>.
  ```

  Всички параметри освен --session-id в тази команда са опционални.

- **Промяна на парола**

  Потребителите могат да променят паролата си, като всички параметри в командата са задължителни.

  ```bash
  reset-password -–session-id –-username <username> --old-password <oldPassword> --new-password <newPassword>
  ```

- **Изход от системата**

  При изход, сесията се инвалидира и подаденото session ID не може да бъде използвано повторно за логин.

  ```bash
  logout –-session-id <sessionId>
  ```

#### Администраторски команди

- **Добавяне на администраторски права на потребител**

  Администраторите могат да създават нови администратори. Правата на новите администратори влизат в действие веднага, без да има необходимост от повторен логин.

  ```bash
  add-admin-user –-session-id <sessionId> –-username <username>
  ```
- **Премахване на администраторски права на потребител**

  Администраторите могат да премахват правата на други администратори. Правата се премахват веднага, без необходимост от повторен логин.

  ```bash
  remove-admin-user –-session-id <sessionId> –-username <username>
  ```
  Aдминистраторът може да премахне дори своите собствени права, освен, ако не е единствен администратор на сървъра.

- **Премахване на потребител**

  Администраторите имат право да премахнат даден регистриран потребител.

  ```bash
  delete-user –-session-id <sessionId> –-username <username>
  ```

  При изтриване на user, се премахва всяка пазена информация за него (без тази в audit log-a), както и се инвалидира сесията му, ако има валидна такава.

## Audit Log

Както споменахме, системата ни ще съхранява и audit log-ове. Трябва да се пазят като текстови файлове на файловата система в предварително конфигурирана директория.

### Типове събития, който ще записваме

- **Неуспешен опит за вход**

  При неуспешен опит за вход логваме следното:

    - Timestamp
    - Тип на събитието (failed login)
    - Извършител - потребителят, който опитва да извърши действието и неговия IP адрес

- **Изпълнение на команди, променящи ресурси на системата** (добавяне/премахване на администратор). Логовете, които се пишат при промяна на ресурс са два:

    - когато операцията започне:

        - Timestamp
        - ID на операцията
        - Тип на събитието (configuration change)
        - Извършител - потребителят, който опитва да извърши действието и неговото IP
        - какво се променя - кой user е засегнат и дали са премахнати или добавени права

    - когато операцията завърши:

        - Timestamp
        - ID на операцията (същото, като това при започване)
        - Тип на събитието (configuration change)
        - Извършител - потребителят, който опитва да извържи действието и неговото IP
        - резултата от нея - дали е била успешна или не

Форматът на логовете е по ваш избор.

## Съобщения за грешки

При неправилно използване на програмата, на потребителя да се извеждат подходящи съобщения за грешка.

При възникване програмна грешка, на потребителя да се извежда само уместна за него информация. Техническа информация за самата грешка и stackтraces да се записват във файл на файловата система - няма определен формат за записване на грешката.

Например, нерелевантно е при команда на потребител и възникнал проблем с мрежовата комуникация, да се изписва грешка от вида на "IO exception occurred: connection reset", по-подходящо би било "Unable to connect to the server. Try again later or contact administrator by providing the logs in <path_to_logs_file>".

При възникване на програмна грешка от страна на сървъра, подходящо съобщение се изписва на конзолата и във файл, като освен това, във файла се записва допълнителна информация (например, при заявка на кой потребител е възникнала грешката, ако въобще е обвързана с потребителско взаимодействие) и stacktraces.

## Уточнения

- User информацията трябва да се пази във файл (ще играе ролята на база от данни за сървъра), като паролата **не трябва** да се пази в plain text
- При повторен login за даден потребител с username и password, предишната създадена сесия (ако има такава) трябва да се инвалидира и да се създаде нова

## Submission

Качете в грейдъра `.zip` архив на познатите директории `src` и `test`. Ако пакетирате допълнителни файлове (които не са .java), те трябва да са в корена на архива, на нивото на `src` и `test`.
В грейдъра няма да има автоматизирани референтни тестове.
Проектът ви трябва да е качен в грейдъра не по-късно от 18:00 в деня преди датата на защитата.

Успех!
